#import "math-lib-core/math.mligo" "Math"
type cookieBaker =
  {
    passiveCPS: nat,
    cookies: nat,
    cursors: nat,
    grandmas: nat,
    farms: nat,
    mines: nat,
    factories: nat,
    banks: nat,
    temples: nat,
    cursorCost: nat,
    grandmaCost: nat,
    farmCost: nat,
    mineCost: nat,
    factoryCost: nat,
    bankCost: nat,
    templeCost: nat,
    eatenCookies: nat
  };

const newCookieBaker: cookieBaker = 
  {passiveCPS: 0 as nat,
   cookies: 0 as nat,
   cursors: 0 as nat,
   grandmas: 0 as nat,
   farms: 0 as nat,
   mines: 0 as nat,
   factories: 0 as nat,
   banks: 0 as nat,
   temples: 0 as nat,
   cursorCost: 0 as nat,
   grandmaCost: 0 as nat,
   farmCost: 0 as nat,
   mineCost: 0 as nat,
   factoryCost: 0 as nat,
   bankCost: 0 as nat,
   templeCost: 0 as nat,
   eatenCookies: 0 as nat};

const initialCursorCost: nat = 15 as nat;

const initialGrandmaCost: nat = 100 as nat;

const initialFarmCost: nat = 1100 as nat;

const initialMineCost: nat = 12000 as nat;

const initialFactoryCost: nat = 130000 as nat;

const initialBankCost: nat = 130000 as nat;

const initialTempleCost: nat = 20000000 as nat;

const cursorCPS: nat = 1 as nat;

const grandmaCPS: nat = 3 as nat;

const farmCPS: nat = 8 as nat;

const mineCPS: nat = 47 as nat;

const factoryCPS: nat = 260 as nat;

const bankCPS: nat = 1400 as nat;

const templeCPS: nat = 7800 as nat;

type storage = map<address, cookieBaker>;

type actions =
  | ["Cookie"]
  | ["Cursor"]
  | ["Grandma"]
  | ["Farm"]
  | ["Mine"]
  | ["Factory"]
  | ["Bank"]
  | ["Temple"];

type operationType = | ["Mint"] | ["Transfer"] | ["Eat"];

type parameter =
  {
    operationType,
    operation: option<actions>,
    amount: nat,
    recipient: option<address>
  };

type return_ =

  [list<operation>,
   storage];

const calculateCost = 
  (ope: actions, cookieBaker: cookieBaker): nat => {match(ope, {Cookie: () => {return (0
       as nat)},
    Cursor: () => {let firstOperation = 
       Math.power(115 as nat, cookieBaker.cursors);
     const first: nat = initialCursorCost * firstOperation;
     const second: nat = 
       first / ((cookieBaker.cursors as nat) * (100 as nat));
     return second},
    Grandma: () => {let firstOperation = 
       Math.power(115 as nat, cookieBaker.grandmas);
     const first: nat = initialGrandmaCost * firstOperation;
     const second: nat = 
       first / ((cookieBaker.cursors as nat) * (100 as nat));
     return second},
    Farm: () => {let firstOperation = 
       Math.power(115 as nat, cookieBaker.farms);
     const first: nat = initialFarmCost * firstOperation;
     const second: nat = 
       first / ((cookieBaker.farms as nat) * (100 as nat));
     return second},
    Mine: () => {let firstOperation = 
       Math.power(115 as nat, cookieBaker.mines);
     const first: nat = initialMineCost * firstOperation;
     const second: nat = 
       first / ((cookieBaker.mines as nat) * (100 as nat));
     return second},
    Factory: () => {let firstOperation = 
       Math.power(115 as nat, cookieBaker.factories);
     const first: nat = initialFactoryCost * firstOperation;
     const second: nat = 
       first / ((cookieBaker.factories as nat) * (100 as nat));
     return second},
    Bank: () => {let firstOperation = 
       Math.power(115 as nat, cookieBaker.banks);
     const first: nat = initialBankCost * firstOperation;
     const second: nat = 
       first / ((cookieBaker.banks as nat) * (100 as nat));
     return second},
    Temple: () => {let firstOperation = 
       Math.power(115 as nat, cookieBaker.temples);
     const first: nat = initialTempleCost * firstOperation;
     const second: nat = 
       first / ((cookieBaker.temples as nat) * (100 as nat));
     return second}})};

const calculateCPS = 
  (cookieBaker: cookieBaker): nat => {let cursor = 
     cookieBaker.cursors * cursorCPS;
   let grandma = cookieBaker.grandmas * grandmaCPS;
   let farm = cookieBaker.farms * farmCPS;
   let mine = cookieBaker.mines * mineCPS;
   let factory = cookieBaker.factories * factoryCPS;
   return cursor + grandma + farm + mine + factory};

const force_access = 
  (key: address, cookieBakers: storage) => {return match(Map.
   find_opt(key, cookieBakers), {Some: cookieBaker => 
      cookieBaker,
    None: () => newCookieBaker})};

const main = 
  ([ope, cookieBakers]: 
    [parameter,
     storage]): return_ => {const player = 
     Tezos.get_source();
   return [list([]),
    match(ope.operationType, {Mint: () => {let operation = 
        Option.unopt_with_error(ope.operation, "Operation is mandatory for minting");
      match(operation, {Cookie: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let cookies = cookieBaker.cookies + (ope.amount as nat);
        let cookieBakers = 
          Map.update(player as address, Some
            ({...cookieBaker, cookies: cookies}), cookieBakers);
        return cookieBakers},
       Cursor: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.cursorCost) {let cursors = 
           cookieBaker.cursors + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.cursorCost);
         let cursorCost = 
           calculateCost(operation, cookieBaker);
         let passiveCPS = calculateCPS(cookieBaker);
         let cookieBakers = 
           Map.update(player as address, Some
             ({...cookieBaker,
              cookies: cookies,
              cursors: cursors,
              cursorCost: cursorCost,
              passiveCPS: passiveCPS}), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Grandma: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.grandmaCost) {let grandmas = 
           cookieBaker.grandmas + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.grandmaCost);
         let grandmaCost = 
           calculateCost(operation, cookieBaker);
         let passiveCPS = calculateCPS(cookieBaker);
         let cookieBakers = 
           Map.update(player as address, Some
             ({...cookieBaker,
              cookies: cookies,
              grandmas: grandmas,
              grandmaCost: grandmaCost,
              passiveCPS: passiveCPS}), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Farm: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.farmCost) {let farms = 
           cookieBaker.farms + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.farmCost);
         let farmCost = 
           calculateCost(operation, cookieBaker);
         let passiveCPS = calculateCPS(cookieBaker);
         let cookieBakers = 
           Map.update(player as address, Some
             ({...cookieBaker,
              cookies: cookies,
              farms: farms,
              farmCost: farmCost,
              passiveCPS: passiveCPS}), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Mine: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.mineCost) {let mines = 
           cookieBaker.mines + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.mineCost);
         let mineCost = 
           calculateCost(operation, cookieBaker);
         let passiveCPS = calculateCPS(cookieBaker);
         let cookieBakers = 
           Map.update(player as address, Some
             ({...cookieBaker,
              cookies: cookies,
              mines: mines,
              mineCost: mineCost,
              passiveCPS: passiveCPS}), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Factory: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.factoryCost) {let factories = 
           cookieBaker.factories + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.factoryCost);
         let factoryCost = 
           calculateCost(operation, cookieBaker);
         let passiveCPS = calculateCPS(cookieBaker);
         let cookieBakers = 
           Map.update(player as address, Some
             ({...cookieBaker,
              cookies: cookies,
              factories: factories,
              factoryCost: factoryCost,
              passiveCPS: passiveCPS}), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Bank: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.bankCost) {let banks = 
           cookieBaker.banks + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.bankCost);
         let bankCost = 
           calculateCost(operation, cookieBaker);
         let passiveCPS = calculateCPS(cookieBaker);
         let cookieBakers = 
           Map.update(player as address, Some
             ({...cookieBaker,
              cookies: cookies,
              banks: banks,
              bankCost: bankCost,
              passiveCPS: passiveCPS}), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Temple: () => {let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.templeCost) {let temples = 
           cookieBaker.temples + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.templeCost);
         let templeCost = 
           calculateCost(operation, cookieBaker);
         let passiveCPS = calculateCPS(cookieBaker);
         let cookieBakers = 
           Map.update(player as address, Some
             ({...cookieBaker,
              cookies: cookies,
              temples: temples,
              templeCost: templeCost,
              passiveCPS: passiveCPS}), cookieBakers);
         return cookieBakers} else {return cookieBakers}}})},
     Eat: () => {let cookieBaker: cookieBaker = 
        force_access(player as address, cookieBakers);
      let eatenCookies = 
        cookieBaker.eatenCookies + (1 as nat);
      let cookieBakers = 
        Map.update(player as address, Some
          ({...cookieBaker, eatenCookies: eatenCookies}), cookieBakers);
      return cookieBakers},
     Transfer: () => {let sender: cookieBaker = 
        force_access(player as address, cookieBakers);
      let rawRecipient = 
        Option.unopt_with_error(ope.recipient, "There is not recipient");
      let recipient = 
        force_access(rawRecipient as address, cookieBakers);
      let cookiesToTransfer = ope.amount as nat;
      let senderCookies = sender.cookies - cookiesToTransfer;
      let recipientCookies = 
        recipient.cookies + cookiesToTransfer;
      let cookieBakers = 
        Map.update(player as address, Some
          ({...sender, cookies: abs(senderCookies)}), cookieBakers);
      let cookieBakers = 
        Map.update(rawRecipient as address, Some
          ({...recipient, cookies: recipientCookies}), cookieBakers);
      return cookieBakers}})]};

const init_storage: storage = Map.empty;
