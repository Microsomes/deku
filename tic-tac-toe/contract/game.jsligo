type cell = ["Cross"] | ["Circle"] | ["Empty"]

type gameState = 
  | ["PlayerTurn", address]
  | ["Winner", address]

type storage = {
  game: list<cell>,
  players: {
    player1: address,
    player2: address
  },
  gameState: gameState
};

const empty: storage = {
  game: list([
    Cross(), Empty(), Circle(), 
    Empty(), Empty(), Empty(), 
    Empty(), Empty(), Empty()
  ]),
  players: {
    player1: "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address, // The two players are the same
    player2: "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address,
  },
  gameState: PlayerTurn("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address)
};

type parameter =
  | ["Play", nat]
  | ["Join"]

type return_ = [list<operation>, storage];

const aux: <T, U> (fct: (i: nat, elt:T) => U, index:nat, ls:list<T>, acc:list<U>) => list<U> = (f, index, ls, acc) => {
  return match(ls, list([
    ([]: list<T>) => acc,
    ([head, ...tl]: list<T>) => {
      let next = f(index, head);
      let nextAcc = list([next, ...acc]);
      return aux(f, index + (1 as nat), tl, nextAcc)
    }
  ]))
};

const mapi: <T, U> (fct:(i: nat, elt: T) => U , ls: list<T>) => list<U> = (f,ls) => {
  let acc: list<U> = list([]);
  return aux(f, 0 as nat, ls, acc)
}

const updateCell = (cellId: nat, value:cell, game: list<cell>) => {
  let apply = (index:nat, elt: cell) => {
    if(cellId != index) return elt
    return match(elt, {
      Cross: () => failwith("Already set: cross"),
      Circle: () => failwith("Already set: circle"),
      Empty: () => value
    })
  };
  return mapi(apply, game)
}

const getSymbol = (player: address, storage: storage): cell => {
  if(player == storage.players.player1) return Cross()
  else return Circle()
}

const play = (player: address, cellId: nat, storage:storage): storage => {
  const {game, players, gameState} = storage;
  let current_player = match(storage.gameState, {
    PlayerTurn: player => player,
    Winner: _ => failwith("Game is ended")
  });
  if(current_player != player) {return failwith("Not your turn")};
  if(cellId > (8 as nat)) {return failwith("Wrong cellId")};
  const value = getSymbol(player, storage);
  const game = updateCell(cellId, value, storage.game);
  return {game, players, gameState}
}

const main = (parameter: parameter, storage: storage): return_ => {
    let player = "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address;
    let operations: list<operation> = list([]);
    let storage = (match (parameter, {
      Play: cellId => play (player, cellId, storage),
      Join: () => failwith("Join is not yet implemented")
    }));
    return [operations, storage]
}