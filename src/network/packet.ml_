open Deku_crypto
open Deku_concepts
open Deku_protocol
open Deku_consensus

type tag = Block | Signature | Operation
type network = Network of { known_packets : Packet_hash.Set.t }
type never = |

module Stream : sig
  type 'elt stream
  and 'elt t = 'elt stream

  val make :
    size:int -> on_element:('elt -> unit Lwt.t) -> 'elt stream * never Lwt.t

  val push : 'elt stream -> 'elt -> unit Lwt.t
end = struct
  (* TODO: let%await *)
  let ( let* ) = Lwt.bind
 
  type 'elt stream = {
    lwt_stream : 'elt Lwt_stream.t;
    lwt_push : 'elt Lwt_stream.bounded_push;
    on_element : 'elt -> unit Lwt.t;
    mutable resolver : unit Lwt.u;
  }

  and 'a t = 'a stream

  let rec loop stream : never Lwt.t =
    let { lwt_stream; lwt_push = _; on_element; resolver = _ } = stream in

    let promise, resolver = Lwt.wait () in
    stream.resolver <- resolver;
    let* () = promise in

    let* () =
      let* elt = Lwt_stream.get lwt_stream in
      match elt with
      | Some elt ->
          (* TODO: what to do in case of exceptions here *)
          on_element elt
      | None -> Lwt.return_unit
    in

    loop stream

  let make ~size ~on_element =
    let lwt_stream, lwt_push = Lwt_stream.create_bounded size in
    let _promise, resolver = Lwt.wait () in
    let stream = { lwt_stream; lwt_push; on_element; resolver } in
    (stream, loop stream)

  let push stream elt =
    let { lwt_stream = _; lwt_push; on_element = _; resolver } = stream in
    let* () = lwt_push#push elt in
    (match Lwt.wakeup_later resolver () with
    | () -> ()
    | exception Invalid_argument _ -> ());
    Lwt.return_unit
end

(* TODO: make it parallel *)
(* module Parallel_stream = struct
     type t = { wakeup : unit Lwt.u }

     (* let make ~max ~parallel = () *)
     (* let x = 1 *)
   end *)

module Repr = struct
  type packet = { hash : Packet_hash.t; content : Yojson.Safe.t }
  type packet_judgement = Duplicated_packet | Invalid_packet | New_packet

  type effect =
    | Broadcast_packet of { tag : tag; packet : packet }
    | Incoming_block of { block : Block.t }
    | Incoming_signature of { signature : Verified_signature.t }
    | Incoming_operation of { operation : Operation.t }

  type action =
    | Noop
    | Effect of effect
    | Both of action * action
    | Incoming_packet of { tag : tag; packet : packet }
    | Parse_content of { tag : tag; content : Yojson.Safe.t }

  let verify_packet ~known_packets packet =
    let { hash; content } = packet in
    match Packet_hash.Set.mem hash known_packets with
    | true -> Duplicated_packet
    | false -> (
        match
          let expected =
            let message = Yojson.Safe.to_string content in
            Packet_hash.hash message
          in
          Packet_hash.equal hash expected
        with
        | true -> New_packet
        | false -> Invalid_packet)

  let incoming_packet tag packet network =
    let (Network { known_packets }) = network in
    match verify_packet ~known_packets packet with
    | Duplicated_packet | Invalid_packet -> (network, Noop)
    | New_packet ->
        let { hash; content } = packet in
        let network =
          let known_packets = Packet_hash.Set.add hash known_packets in
          Network { known_packets }
        in
        ( network,
          Both
            ( Parse_content { tag; content },
              Effect (Broadcast_packet { tag; packet }) ) )

  let parse_content tag content =
    try
      match tag with
      | Block ->
          let block = Block.t_of_yojson content in
          Effect (Incoming_block { block })
      | Signature -> assert false
      | Operation ->
          let operation = Operation.t_of_yojson content in
          Effect (Incoming_operation { operation })
    with _exn -> (* TODO: print this exception*) Noop

  let rec reducer action network =
    match action with
    | Noop -> (network, [])
    | Effect effect -> (network, [ effect ])
    | Both (left, right) ->
        let network, left_effects = reducer left network in
        let network, right_effects = reducer right network in
        (network, left_effects @ right_effects)
    | Incoming_packet { tag; packet } ->
        let network, action = incoming_packet tag packet network in
        reducer action network
    | Parse_content { tag; content } ->
        let action = parse_content tag content in
        reducer action network

  (* let incoming_block packet network =
     let { hash; content = _ } = packet in
     match verify_packet ~known_packets packet with
     | Duplicated_packet -> network
     | Invalid_packet -> network
     | New_packet ->
       let network = let known_packets = Packet_hash.Set.add hash known_packets in
       Network { known_packets } *)
end
