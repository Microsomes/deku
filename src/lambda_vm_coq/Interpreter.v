(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Inductive _error : Set :=
| Undefined_variable : _error
| Over_applied_primitives : _error
| Value_is_not_pair : _error
| Value_is_not_int64 : _error
| Value_is_not_function : _error
| Value_is_not_zero : _error.

Definition raise {A : Set} (_error : _error) : A :=
  Stdlib.raise (Build_extensible "Error" _error _error).

Module Pattern.
  Definition nil : Set := unit.
  
  Inductive t : Set :=
  | Any : t
  | Pair : t -> t -> t
  | Nil : t.
  
  Definition any : t := Any.
  
  Definition pair_value (first : t) (second : t) : t := Pair first second.
  
  Definition nil : t := Nil.
  
  Definition operations : t := nil.
  
  Definition script_result : t := pair_value any (pair_value operations nil).
  
  Fixpoint parse {a : Set} (value : Lambda_vm.Ir.value) (t_value : t) : a :=
    match (t_value, value) with
    | (Any, value) => value
    |
      (Pair first_t second_t,
        Lambda_vm.Ir.V_pair {|
          Lambda_vm.Ir.value.V_pair.first := first_value;
            Lambda_vm.Ir.value.V_pair.second := second_value
            |}) =>
      let first := parse first_value first_t in
      let second := parse second_value second_t in
      (first, second)
    |
      (Pair _ _,
        (Lambda_vm.Ir.V_int64 _ | Lambda_vm.Ir.V_closure _ |
        Lambda_vm.Ir.V_primitive _)) => raise Value_is_not_pair
    |
      (Nil,
        Lambda_vm.Ir.V_int64
          (* ❌ Constant of type int64 is converted to int *)
          0) => tt
    |
      (Nil,
        (Lambda_vm.Ir.V_int64 _ | Lambda_vm.Ir.V_pair _ |
        Lambda_vm.Ir.V_closure _ | Lambda_vm.Ir.V_primitive _)) =>
      raise Value_is_not_zero
    end.
End Pattern.

Definition Env :=
  Lambda_vm.Map_with_cardinality.Make
    {|
      Stdlib.Map.OrderedType.compare := Lambda_vm.Ident.compare
    |}.

Definition burn_gas {A : Set}
  (gas : Lambda_vm.Gas.t) (env : Env.(Lambda_vm.Map_with_cardinality.S.t) A)
  (code : Lambda_vm.Ir.expr) : unit :=
  let '_ := Lambda_vm.Checks.check_gas gas in
  match code with
  | (Lambda_vm.Ir.E_var _ | Lambda_vm.Ir.E_app _) =>
    let cardinality := Env.(Lambda_vm.Map_with_cardinality.S.cardinal) env in
    Lambda_vm.Gas.burn_log2 gas cardinality
  |
    (Lambda_vm.Ir.E_lam _ _ | Lambda_vm.Ir.E_const _ | Lambda_vm.Ir.E_prim _ |
    Lambda_vm.Ir.E_if _ | Lambda_vm.Ir.E_pair _) =>
    Lambda_vm.Gas.burn_constant gas
  end.

Definition eval_prim
  (prim : Lambda_vm.Ir.prim) (arg : Lambda_vm.Ir.value)
  (args : list Lambda_vm.Ir.value) : Lambda_vm.Ir.value :=
  let op1_int64 (f_value : int64 -> int64) : Lambda_vm.Ir.value :=
    let f_value (value : Lambda_vm.Ir.value) : Lambda_vm.Ir.value :=
      match value with
      | Lambda_vm.Ir.V_int64 value => Lambda_vm.Ir.V_int64 (f_value value)
      |
        (Lambda_vm.Ir.V_pair _ | Lambda_vm.Ir.V_closure _ |
        Lambda_vm.Ir.V_primitive _) => raise Value_is_not_int64
      end in
    match args with
    | [] => f_value arg
    | _ => raise Over_applied_primitives
    end in
  let op1_pair {A : Set}
    (f_value : Lambda_vm.Ir.value -> Lambda_vm.Ir.value -> A) : A :=
    let f_value (value : Lambda_vm.Ir.value) : A :=
      match value with
      |
        Lambda_vm.Ir.V_pair {|
          Lambda_vm.Ir.value.V_pair.first := first;
            Lambda_vm.Ir.value.V_pair.second := second
            |} => f_value first second
      |
        (Lambda_vm.Ir.V_int64 _ | Lambda_vm.Ir.V_closure _ |
        Lambda_vm.Ir.V_primitive _) => raise Value_is_not_pair
      end in
    match args with
    | [] => f_value arg
    | _ => raise Over_applied_primitives
    end in
  let op2 (f_value : int64 -> int64 -> int64) : Lambda_vm.Ir.value :=
    let f_value (_left : Lambda_vm.Ir.value) (_right : Lambda_vm.Ir.value)
      : Lambda_vm.Ir.value :=
      match (_left, _right) with
      | (Lambda_vm.Ir.V_int64 _left, Lambda_vm.Ir.V_int64 _right) =>
        Lambda_vm.Ir.V_int64 (f_value _left _right)
      |
        ((Lambda_vm.Ir.V_pair _ | Lambda_vm.Ir.V_int64 _ |
        Lambda_vm.Ir.V_closure _ | Lambda_vm.Ir.V_primitive _),
          (Lambda_vm.Ir.V_pair _ | Lambda_vm.Ir.V_int64 _ |
          Lambda_vm.Ir.V_closure _ | Lambda_vm.Ir.V_primitive _)) =>
        raise Value_is_not_int64
      end in
    match args with
    | [] =>
      Lambda_vm.Ir.V_primitive
        {| Lambda_vm.Ir.value.V_primitive.args := [ arg ];
          Lambda_vm.Ir.value.V_primitive.prim := prim |}
    | cons _left [] => f_value _left arg
    | _ => raise Over_applied_primitives
    end in
  let op2_shift (f_value : int64 -> int -> int64) : Lambda_vm.Ir.value :=
    let f_value (_left : int64) (_right : int64) : int64 :=
      f_value _left (Stdlib.Int64.to_int _right) in
    op2 f_value in
  match prim with
  | Lambda_vm.Ir.P_neg => op1_int64 Stdlib.Int64.neg
  | Lambda_vm.Ir.P_add => op2 Stdlib.Int64.add
  | Lambda_vm.Ir.P_sub => op2 Stdlib.Int64.sub
  | Lambda_vm.Ir.P_mul => op2 Stdlib.Int64.mul
  | Lambda_vm.Ir.P_div => op2 Stdlib.Int64.div
  | Lambda_vm.Ir.P_rem => op2 Stdlib.Int64.rem
  | Lambda_vm.Ir.P_land => op2 Stdlib.Int64.logand
  | Lambda_vm.Ir.P_lor => op2 Stdlib.Int64.logor
  | Lambda_vm.Ir.P_lxor => op2 Stdlib.Int64.logxor
  | Lambda_vm.Ir.P_lsl => op2_shift Stdlib.Int64.shift_left
  | Lambda_vm.Ir.P_lsr => op2_shift Stdlib.Int64.shift_right_logical
  | Lambda_vm.Ir.P_asr => op2_shift Stdlib.Int64.shift_right
  | Lambda_vm.Ir.P_fst =>
    op1_pair
      (fun (fst : Lambda_vm.Ir.value) => fun (_snd : Lambda_vm.Ir.value) => fst)
  | Lambda_vm.Ir.P_snd =>
    op1_pair
      (fun (_fst : Lambda_vm.Ir.value) => fun (snd : Lambda_vm.Ir.value) => snd)
  end.

Fixpoint eval
  (stack : int) (gas : Lambda_vm.Gas.t)
  (env : Env.(Lambda_vm.Map_with_cardinality.S.t) Lambda_vm.Ir.value)
  (code : Lambda_vm.Ir.expr) : Lambda_vm.Ir.value :=
  let eval_call
    (env : Env.(Lambda_vm.Map_with_cardinality.S.t) Lambda_vm.Ir.value)
    (code : Lambda_vm.Ir.expr) : Lambda_vm.Ir.value :=
    eval (Z.sub stack 1) gas env code in
  let eval_jump
    (env : Env.(Lambda_vm.Map_with_cardinality.S.t) Lambda_vm.Ir.value)
    (code : Lambda_vm.Ir.expr) : Lambda_vm.Ir.value :=
    eval stack gas env code in
  let '_ := Lambda_vm.Checks.check_stack stack in
  let '_ := burn_gas gas env code in
  match code with
  | Lambda_vm.Ir.E_var var =>
    match Env.(Lambda_vm.Map_with_cardinality.S.find) var env with
    | Some value => value
    | None => raise Undefined_variable
    end
  | Lambda_vm.Ir.E_lam param body =>
    Lambda_vm.Ir.V_closure
      {| Lambda_vm.Ir.value.V_closure.env := env;
        Lambda_vm.Ir.value.V_closure.param := param;
        Lambda_vm.Ir.value.V_closure.body := body |}
  |
    Lambda_vm.Ir.E_app {|
      Lambda_vm.Ir.expr.E_app.funct := funct;
        Lambda_vm.Ir.expr.E_app.arg := arg
        |} =>
    let funct := eval_call env funct in
    let arg := eval_call env arg in
    match funct with
    | (Lambda_vm.Ir.V_pair _ | Lambda_vm.Ir.V_int64 _) =>
      raise Value_is_not_function
    |
      Lambda_vm.Ir.V_closure {|
        Lambda_vm.Ir.value.V_closure.env := env;
          Lambda_vm.Ir.value.V_closure.param := param;
          Lambda_vm.Ir.value.V_closure.body := body
          |} =>
      let env := Env.(Lambda_vm.Map_with_cardinality.S.add) param arg env in
      eval_jump env body
    |
      Lambda_vm.Ir.V_primitive {|
        Lambda_vm.Ir.value.V_primitive.args := args;
          Lambda_vm.Ir.value.V_primitive.prim := prim
          |} => eval_prim prim arg args
    end
  | Lambda_vm.Ir.E_const value => Lambda_vm.Ir.V_int64 value
  | Lambda_vm.Ir.E_prim prim =>
    Lambda_vm.Ir.V_primitive
      {| Lambda_vm.Ir.value.V_primitive.args := nil;
        Lambda_vm.Ir.value.V_primitive.prim := prim |}
  |
    Lambda_vm.Ir.E_if {|
      Lambda_vm.Ir.expr.E_if.predicate := predicate;
        Lambda_vm.Ir.expr.E_if.consequent := consequent;
        Lambda_vm.Ir.expr.E_if.alternative := alternative
        |} =>
    let predicate := eval_call env predicate in
    match predicate with
    |
      Lambda_vm.Ir.V_int64
        (* ❌ Constant of type int64 is converted to int *)
        0 => eval_jump env alternative
    | Lambda_vm.Ir.V_int64 _ => eval_jump env consequent
    |
      (Lambda_vm.Ir.V_pair _ | Lambda_vm.Ir.V_closure _ |
      Lambda_vm.Ir.V_primitive _) => raise Value_is_not_int64
    end
  |
    Lambda_vm.Ir.E_pair {|
      Lambda_vm.Ir.expr.E_pair.first := first;
        Lambda_vm.Ir.expr.E_pair.second := second
        |} =>
    let first := eval_call env first in
    let second := eval_call env second in
    Lambda_vm.Ir.V_pair
      {| Lambda_vm.Ir.value.V_pair.first := first;
        Lambda_vm.Ir.value.V_pair.second := second |}
  end.

Definition eval
  (gas : Lambda_vm.Gas.t)
  (env : Env.(Lambda_vm.Map_with_cardinality.S.t) Lambda_vm.Ir.value)
  (code : Lambda_vm.Ir.expr) : Lambda_vm.Ir.value :=
  let stack := Lambda_vm.Checks.max_stack_depth in
  eval stack gas env code.

Module script_result.
  Record record : Set := Build {
    storage : Lambda_vm.Ir.value;
    operations : unit }.
  Definition with_storage storage (r : record) :=
    Build storage r.(operations).
  Definition with_operations operations (r : record) :=
    Build r.(storage) operations.
End script_result.
Definition script_result := script_result.record.

Definition execute
  (gas : Lambda_vm.Gas.t) (arg : Lambda_vm.Ir.value)
  (script : Lambda_vm.Ir.script) : script_result :=
  let '{|
    Lambda_vm.Ir.script.param := param; Lambda_vm.Ir.script.code := code |} :=
    script in
  let env :=
    Env.(Lambda_vm.Map_with_cardinality.S.add) param arg
      Env.(Lambda_vm.Map_with_cardinality.S.empty) in
  let output := eval gas env code in
  let '(storage, (operations, _)) := Pattern.parse output Pattern.script_result
    in
  {| script_result.storage := storage; script_result.operations := operations |}.

Definition execute
  (gas : Lambda_vm.Gas.t) (arg : Lambda_vm.Ir.value)
  (script : Lambda_vm.Ir.script) : sum script_result _error :=
  (* ❌ Use a trivial matching for the `with` clause, like: *)
  typ_with_with_non_trivial_matching.
