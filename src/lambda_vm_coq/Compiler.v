(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Definition String_map :=
  Stdlib.Map.Make
    {|
      Stdlib.Map.OrderedType.compare := Stdlib.String.compare
    |}.

Inductive _error : Set :=
| Undefined_variable : _error.

Definition raise {A : Set} (_error : _error) : A :=
  Stdlib.raise (Build_extensible "Error" _error _error).

Definition compile_prim (prim : Lambda_vm.Ast.prim) : Lambda_vm.Ir.prim :=
  match prim with
  | Lambda_vm.Ast.Neg => Lambda_vm.Ir.P_neg
  | Lambda_vm.Ast.Add => Lambda_vm.Ir.P_add
  | Lambda_vm.Ast.Sub => Lambda_vm.Ir.P_sub
  | Lambda_vm.Ast.Mul => Lambda_vm.Ir.P_mul
  | Lambda_vm.Ast.Div => Lambda_vm.Ir.P_div
  | Lambda_vm.Ast.Rem => Lambda_vm.Ir.P_rem
  | Lambda_vm.Ast.Land => Lambda_vm.Ir.P_land
  | Lambda_vm.Ast.Lor => Lambda_vm.Ir.P_lor
  | Lambda_vm.Ast.Lxor => Lambda_vm.Ir.P_lxor
  | Lambda_vm.Ast.Lsl => Lambda_vm.Ir.P_lsl
  | Lambda_vm.Ast.Lsr => Lambda_vm.Ir.P_lsr
  | Lambda_vm.Ast.Asr => Lambda_vm.Ir.P_asr
  | Lambda_vm.Ast.Fst => Lambda_vm.Ir.P_fst
  | Lambda_vm.Ast.Snd => Lambda_vm.Ir.P_snd
  end.

Definition Vars :=
  Lambda_vm.Map_with_cardinality.Make
    {|
      Stdlib.Map.OrderedType.compare := Stdlib.String.compare
    |}.

Definition burn_gas {A : Set}
  (gas : Lambda_vm.Gas.t) (vars : Vars.(Lambda_vm.Map_with_cardinality.S.t) A)
  (code : Lambda_vm.Ast.expr) : unit :=
  let '_ := Lambda_vm.Checks.check_gas gas in
  match code with
  | (Lambda_vm.Ast.Var _ | Lambda_vm.Ast.Lam _ _) =>
    let cardinality := Vars.(Lambda_vm.Map_with_cardinality.S.cardinal) vars in
    Lambda_vm.Gas.burn_log2 gas cardinality
  |
    (Lambda_vm.Ast.App _ | Lambda_vm.Ast.Const _ | Lambda_vm.Ast.Prim _ |
    Lambda_vm.Ast.If _ | Lambda_vm.Ast.Pair _) =>
    Lambda_vm.Gas.burn_constant gas
  end.

Fixpoint compile_expr
  (stack : int) (gas : Lambda_vm.Gas.t)
  (next_ident : Stdlib.ref Lambda_vm.Ident.t)
  (vars : Vars.(Lambda_vm.Map_with_cardinality.S.t) Lambda_vm.Ir.ident)
  (code : Lambda_vm.Ast.expr) : Lambda_vm.Ir.expr :=
  let stack := Z.sub stack 1 in
  let '_ := Lambda_vm.Checks.check_stack stack in
  let '_ := burn_gas gas vars code in
  let compile_expr
    (vars : Vars.(Lambda_vm.Map_with_cardinality.S.t) Lambda_vm.Ir.ident)
    (code : Lambda_vm.Ast.expr) : Lambda_vm.Ir.expr :=
    compile_expr stack gas next_ident vars code in
  match code with
  | Lambda_vm.Ast.Var var =>
    match Vars.(Lambda_vm.Map_with_cardinality.S.find) var vars with
    | Some ident => Lambda_vm.Ir.E_var ident
    | None => raise Undefined_variable
    end
  | Lambda_vm.Ast.Lam var body =>
    let ident :=
      let ident := Stdlib.op_exclamation next_ident in
      let '_ := Stdlib.op_coloneq next_ident (Lambda_vm.Ident.next ident) in
      ident in
    let vars := Vars.(Lambda_vm.Map_with_cardinality.S.add) var ident vars in
    let body := compile_expr vars body in
    Lambda_vm.Ir.E_lam ident body
  |
    Lambda_vm.Ast.App {|
      Lambda_vm.Ast.expr.App.funct := funct;
        Lambda_vm.Ast.expr.App.arg := arg
        |} =>
    let funct := compile_expr vars funct in
    let arg := compile_expr vars arg in
    Lambda_vm.Ir.E_app
      {| Lambda_vm.Ir.expr.E_app.funct := funct;
        Lambda_vm.Ir.expr.E_app.arg := arg |}
  | Lambda_vm.Ast.Const value => Lambda_vm.Ir.E_const value
  | Lambda_vm.Ast.Prim prim =>
    let prim := compile_prim prim in
    Lambda_vm.Ir.E_prim prim
  |
    Lambda_vm.Ast.If {|
      Lambda_vm.Ast.expr.If.predicate := predicate;
        Lambda_vm.Ast.expr.If.consequent := consequent;
        Lambda_vm.Ast.expr.If.alternative := alternative
        |} =>
    let predicate := compile_expr vars predicate in
    let consequent := compile_expr vars consequent in
    let alternative := compile_expr vars alternative in
    Lambda_vm.Ir.E_if
      {| Lambda_vm.Ir.expr.E_if.predicate := predicate;
        Lambda_vm.Ir.expr.E_if.consequent := consequent;
        Lambda_vm.Ir.expr.E_if.alternative := alternative |}
  |
    Lambda_vm.Ast.Pair {|
      Lambda_vm.Ast.expr.Pair.first := first;
        Lambda_vm.Ast.expr.Pair.second := second
        |} =>
    let first := compile_expr vars first in
    let second := compile_expr vars second in
    Lambda_vm.Ir.E_pair
      {| Lambda_vm.Ir.expr.E_pair.first := first;
        Lambda_vm.Ir.expr.E_pair.second := second |}
  end.

Definition compile_expr
  (gas : Lambda_vm.Gas.t) (next_ident : Stdlib.ref Lambda_vm.Ident.t)
  (vars : Vars.(Lambda_vm.Map_with_cardinality.S.t) Lambda_vm.Ir.ident)
  (code : Lambda_vm.Ast.expr) : Lambda_vm.Ir.expr :=
  let stack := Lambda_vm.Checks.max_stack_depth in
  compile_expr stack gas next_ident vars code.

Definition compile (gas : Lambda_vm.Gas.t) (script : Lambda_vm.Ast.script)
  : Lambda_vm.Ir.script :=
  let '{|
    Lambda_vm.Ast.script.param := param;
      Lambda_vm.Ast.script.code := code
      |} := script in
  let '(param_ident, next_ident) :=
    let param_ident := Lambda_vm.Ident.initial in
    let next_ident := Lambda_vm.Ident.next param_ident in
    (param_ident, (Stdlib.ref_value next_ident)) in
  let vars :=
    Vars.(Lambda_vm.Map_with_cardinality.S.add) param param_ident
      Vars.(Lambda_vm.Map_with_cardinality.S.empty) in
  let code := compile_expr gas next_ident vars code in
  {| Lambda_vm.Ir.script.param := param_ident; Lambda_vm.Ir.script.code := code
    |}.

Definition compile (gas : Lambda_vm.Gas.t) (script : Lambda_vm.Ast.script)
  : sum Lambda_vm.Ir.script _error :=
  (* ❌ Use a trivial matching for the `with` clause, like: *)
  typ_with_with_non_trivial_matching.

Definition burn_gas (gas : Lambda_vm.Gas.t) : unit :=
  let '_ := Lambda_vm.Checks.check_gas gas in
  Lambda_vm.Gas.burn_constant gas.

Fixpoint compile_value
  (stack : int) (gas : Lambda_vm.Gas.t) (value : Lambda_vm.Ast.value)
  : Lambda_vm.Ir.value :=
  let compile_value (value : Lambda_vm.Ast.value) : Lambda_vm.Ir.value :=
    compile_value (Z.sub stack 1) gas value in
  let '_ := Lambda_vm.Checks.check_stack stack in
  let '_ := burn_gas gas in
  match value with
  | Lambda_vm.Ast.Int64 value => Lambda_vm.Ir.V_int64 value
  | Lambda_vm.Ast.Pair first second =>
    let first := compile_value first in
    let second := compile_value second in
    Lambda_vm.Ir.V_pair
      {| Lambda_vm.Ir.value.V_pair.first := first;
        Lambda_vm.Ir.value.V_pair.second := second |}
  end.

Definition compile_value (gas : Lambda_vm.Gas.t) (value : Lambda_vm.Ast.value)
  : Lambda_vm.Ir.value :=
  let stack := Lambda_vm.Checks.max_stack_depth in
  compile_value stack gas value.

Definition compile_value (gas : Lambda_vm.Gas.t) (value : Lambda_vm.Ast.value)
  : sum Lambda_vm.Ir.value _error :=
  (* ❌ Use a trivial matching for the `with` clause, like: *)
  typ_with_with_non_trivial_matching.
