/*! For license information please see ec81c593.d3910000.js.LICENSE.txt */
(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[855],{41535:(n,t)=>{"use strict";var e=Symbol.for("react.element"),a=Symbol.for("react.portal"),i=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),l=Symbol.for("react.provider"),c=Symbol.for("react.context"),s=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),p=Symbol.for("react.memo"),$=Symbol.for("react.lazy"),m=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},d=Object.assign,g={};function _(n,t,e){this.props=n,this.context=t,this.refs=g,this.updater=e||f}function v(){}function b(n,t,e){this.props=n,this.context=t,this.refs=g,this.updater=e||f}_.prototype.isReactComponent={},_.prototype.setState=function(n,t){if("object"!=typeof n&&"function"!=typeof n&&null!=n)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,n,t,"setState")},_.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")},v.prototype=_.prototype;var k=b.prototype=new v;k.constructor=b,d(k,_.prototype),k.isPureReactComponent=!0;var y=Array.isArray,h=Object.prototype.hasOwnProperty,w={current:null},x={key:!0,ref:!0,__self:!0,__source:!0};function S(n,t,a){var i,r={},o=null,l=null;if(null!=t)for(i in void 0!==t.ref&&(l=t.ref),void 0!==t.key&&(o=""+t.key),t)h.call(t,i)&&!x.hasOwnProperty(i)&&(r[i]=t[i]);var c=arguments.length-2;if(1===c)r.children=a;else if(1<c){for(var s=Array(c),u=0;u<c;u++)s[u]=arguments[u+2];r.children=s}if(n&&n.defaultProps)for(i in c=n.defaultProps)void 0===r[i]&&(r[i]=c[i]);return{$$typeof:e,type:n,key:o,ref:l,props:r,_owner:w.current}}function C(n){return"object"==typeof n&&null!==n&&n.$$typeof===e}var j=/\/+/g;function q(n,t){return"object"==typeof n&&null!==n&&null!=n.key?function(n){var t={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,(function(n){return t[n]}))}(""+n.key):t.toString(36)}function z(n,t,i,r,o){var l=typeof n;"undefined"!==l&&"boolean"!==l||(n=null);var c=!1;if(null===n)c=!0;else switch(l){case"string":case"number":c=!0;break;case"object":switch(n.$$typeof){case e:case a:c=!0}}if(c)return o=o(c=n),n=""===r?"."+q(c,0):r,y(o)?(i="",null!=n&&(i=n.replace(j,"$&/")+"/"),z(o,t,i,"",(function(n){return n}))):null!=o&&(C(o)&&(o=function(n,t){return{$$typeof:e,type:n.type,key:t,ref:n.ref,props:n.props,_owner:n._owner}}(o,i+(!o.key||c&&c.key===o.key?"":(""+o.key).replace(j,"$&/")+"/")+n)),t.push(o)),1;if(c=0,r=""===r?".":r+":",y(n))for(var s=0;s<n.length;s++){var u=r+q(l=n[s],s);c+=z(l,t,i,u,o)}else if(u=function(n){return null===n||"object"!=typeof n?null:"function"==typeof(n=m&&n[m]||n["@@iterator"])?n:null}(n),"function"==typeof u)for(n=u.call(n),s=0;!(l=n.next()).done;)c+=z(l=l.value,t,i,u=r+q(l,s++),o);else if("object"===l)throw t=String(n),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(n).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function D(n,t,e){if(null==n)return n;var a=[],i=0;return z(n,a,"","",(function(n){return t.call(e,n,i++)})),a}function P(n){if(-1===n._status){var t=n._result;(t=t()).then((function(t){0!==n._status&&-1!==n._status||(n._status=1,n._result=t)}),(function(t){0!==n._status&&-1!==n._status||(n._status=2,n._result=t)})),-1===n._status&&(n._status=0,n._result=t)}if(1===n._status)return n._result.default;throw n._result}var R={current:null},B={transition:null}},27378:(n,t,e)=>{"use strict";e(41535)},4270:(n,t,e)=>{"use strict";e.d(t,{Z:()=>o});var a=e(42214);const i={pair:(n,t)=>["Pair",n,t],some:n=>["Option","Some",n],none:()=>["Option","None"],map:n=>["Map",...Object.entries(n)],set:function(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];return["Set",...t]},list:function(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];return["List",...t]},unit:()=>["Unit"],int:n=>["Int",n],bool:n=>["Bool",n?"True":"False"]},r=new a.iv("edsk3ym86W81aL2gfZ25WuWQrisJM5Vu8cEayCR6BGsRNgfRWos8mR"),o={incrementLigoCode:'\ntype storage = int;\n\ntype parameter =\n  {kind: "Increment", amount: int}|\n  {kind: "Decrement", amount: int}|\n  {kind: "Reset"};\n\ntype return_ = [list<operation>, storage];\n\nconst main =  (action: parameter, store: storage): return_ => {\n\n  const noop = (list([]) as list<operation>);\n\n  switch(action.kind) {\n    case "Increment":\n      return [noop, (store + action.amount)]\n\n    case "Decrement":\n      return [noop, (store - action.amount)]\n\n    case "Reset":\n       return [noop, 0]\n  }\n};\n',incrementWASMCode:'\n    (module\n      (import "env" "dup_host" (func $dup_host (param i64 ) (result)))\n    (import "env" "pair" (func $pair (param i64 i64) (result i64)))\n    (import "env" "unpair" (func $unpair (param i64)))\n    (import "env" "z_add" (func $z_add (param i64 i64) (result i64)))\n    (import "env" "z_sub" (func $z_sub (param i64 i64) (result i64)))\n    (import "env" "z_mul" (func $z_mul (param i64 i64) (result i64)))\n    (import "env" "neg" (func $neg (param i64) (result i64)))\n    (import "env" "lsl" (func $lsl (param i64 i64) (result i64)))\n    (import "env" "lsr" (func $lsr (param i64 i64) (result i64)))\n    (import "env" "compare" (func $compare (param i64 i64) (result i64)))\n    (import "env" "car" (func $car (param i64) (result i64)))\n    (import "env" "cdr" (func $cdr (param i64) (result i64)))\n    (import "env" "some" (func $some (param i64) (result i64)))\n    (import "env" "nil" (func $nil (result i64)))\n    (import "env" "none" (func $none (result i64)))\n    (import "env" "unit" (func $unit (result i64)))\n    (import "env" "zero" (func $zero (result i64)))\n    (import "env" "empty_map" (func $empty_map (result i64)))\n    (import "env" "empty_set" (func $empty_set (result i64)))\n    (import "env" "empty_big_map" (func $empty_big_map (result i64)))\n    (import "env" "sender" (func $sender (result i64)))\n    (import "env" "source" (func $source (result i64)))\n    (import "env" "map_get" (func $map_get (param i64 i64) (result i64)))\n    (import "env" "mem" (func $mem (param i64 i64) (result i64)))\n    (import "env" "update" (func $update (param i64 i64 i64) (result i64)))\n    (import "env" "iter" (func $iter (param i64 i32) (result )))\n    (import "env" "map" (func $map (param i64 i32) (result i64)))\n    (import "env" "if_left" (func $if_left (param i64) (result i32)))\n    (import "env" "if_none" (func $if_none (param i64) (result i32)))\n    (import "env" "if_cons" (func $if_cons (param i64) (result i32)))\n    (import "env" "isnat" (func $isnat (param i64) (result i64)))\n    (import "env" "not" (func $not (param i64) (result i64)))\n    (import "env" "or" (func $or (param i64 i64) (result i64)))\n    (import "env" "and" (func $and (param i64 i64) (result i64)))\n    (import "env" "xor" (func $xor (param i64 i64) (result i64)))\n    (import "env" "deref_bool" (func $deref_bool (param i64) (result i32)))\n    (import "env" "neq" (func $neq (param i64) (result i64)))\n    (import "env" "failwith" (func $failwith (param i64)))\n    (import "env" "get_n" (func $get_n (param i32 i64) (result i64)))\n    (import "env" "exec" (func $exec (param i64 i64) (result i64)))\n    (import "env" "apply" (func $apply (param i64 i64) (result i64)))\n    (import "env" "const" (func $const (param i32) (result i64)))\n    (import "env" "abs" (func $abs (param i64) (result i64)))\n    (import "env" "eq" (func $eq (param i64) (result i64)))\n    (import "env" "gt" (func $gt (param i64) (result i64)))\n    (import "env" "lt" (func $lt (param i64) (result i64)))\n    (import "env" "closure" (func $closure (param i32) (result i64)))\n    (import "env" "left" (func $left (param i64) (result i64)))\n    (import "env" "right" (func $right (param i64) (result i64)))\n    (import "env" "cons" (func $cons (param i64 i64) (result i64)))\n    (import "env" "transfer_tokens" (func $transfer_tokens (param i64 i64 i64) (result i64)))\n    (import "env" "address" (func $address (param i64) (result i64)))\n    (import "env" "contract" (func $contract (param i64) (result i64)))\n    (import "env" "self" (func $self (result i64)))\n    (import "env" "self_address" (func $self_address (result i64)))\n    (import "env" "get_and_update" (func $get_and_update (param i64 i64 i64)))\n    (import "env" "read_ticket" (func $read_ticket (param i64)))\n    (import "env" "ticket" (func $ticket (param i64 i64) (result i64)))\n    (import "env" "join_tickets" (func $join_tickets (param i64) (result i64)))\n    (import "env" "split_ticket" (func $split_ticket (param i64 i64) (result i64)))\n    (import "env" "amount" (func $amount (result i64)))\n    (import "env" "balance" (func $balance (result i64)))\n    (import "env" "ediv" (func $ediv (param i64 i64) (result i64)))\n    (import "env" "ge" (func $ge (param i64) (result i64)))\n    (import "env" "le" (func $le (param i64) (result i64)))\n    (import "env" "size" (func $size (param i64) (result i64)))\n    (import "env" "int" (func $int (param i64) (result i64)))\n    (import "env" "implicit_account" (func $implicit_account (param i64) (result i64)))\n    (import "env" "blake2b" (func $blake2b (param i64) (result i64)))\n    (import "env" "pack" (func $pack (param i64) (result i64)))\n    (import "env" "unpack" (func $unpack (param i64) (result i64)))\n    (import "env" "keccak" (func $keccak (param i64) (result i64)))\n    (import "env" "sha256" (func $sha256 (param i64) (result i64)))\n    (import "env" "sha3" (func $sha3 (param i64) (result i64)))\n    (import "env" "sha512" (func $sha512 (param i64) (result i64)))\n    \n      (global $mode i32 (i32.const 0))\n    \n      (memory 4)\n      (global $sp (mut i32) (i32.const 4000)) ;; stack pointer\n      (global $sh_sp (mut i32) (i32.const 1000)) ;;shadow_stack stack pointer\n    \n      (global $__stack_base i32 (i32.const 32768))\n    \n      (type $callback_t (func (param i64) (result i64)))\n      (func $call_callback (param $arg1 i64) (param $idx i32) (result i64)\n        (call_indirect (type $callback_t) (local.get $arg1) (local.get $idx)))\n    \n      (type $callback_t_unit (func (param i64) (result)))\n      (func $call_callback_unit (param $arg1 i64) (param $idx i32) (result )\n        (call_indirect (type $callback_t_unit)\n          (local.get $arg1)\n          (local.get $idx)))\n    \n      (func $dip (param $n i32) (result)\n        (local $stop i32)\n        (local $sp\' i32)\n        (local $sh_sp\' i32)\n        (local.set $stop (i32.const 0))\n        (local.set $sp\'  (global.get $sp))\n        (local.tee $sh_sp\' (i32.sub (global.get $sh_sp) (local.get $n)))\n        global.set $sh_sp\n        (loop $l\n          (i32.mul (i32.const 8) (i32.add (global.get $__stack_base) (i32.add (local.get $sh_sp\') (local.get $stop))))\n          (i64.load (i32.mul (i32.const 8) (i32.add (local.get $sp\') (local.get $stop))))\n          i64.store\n          (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))\n          (local.get $n)\n          i32.ne\n          br_if $l)\n    \n        (global.set $sp\n        (i32.add\n          (local.get $sp\') (local.get $n))))\n    \n      (func $undip (param $n i32) (result)\n        (local $stop i32)\n        (local $sp\' i32)\n        (local $sh_sp\' i32)\n        (local.tee $sp\'  (i32.sub (global.get $sp) (local.get $n)))\n        global.set $sp\n        (local.set $sh_sp\' (global.get $sh_sp))\n        (local.set $stop (i32.const 0))\n        (loop $l\n          (i32.mul (i32.const 8) (i32.add (local.get $sp\') (local.get $stop)))\n          (i64.load\n            (i32.add\n              (global.get $__stack_base)\n              (i32.mul (i32.const 8) (i32.add (local.get $sh_sp\') (local.get $stop)))))\n          (i64.store)\n          (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))\n          (local.get $n)\n          i32.ne\n          br_if $l)\n        (global.set $sh_sp (i32.add (local.get $sh_sp\') (local.get $n))))\n    \n      (func $dup (param $n i32) (result)\n        (i64.load (i32.mul (i32.const 8) (i32.add (global.get $sp) (local.get $n))))\n        (call $dup_host))\n    \n      (func $swap (param) (result)\n        (local $v1 i64)\n        (local $v2 i64)\n        (local.set $v1 (call $pop))\n        (local.set $v2 (call $pop))\n        (call $push (local.get $v1))\n        (call $push (local.get $v2)))\n    \n      (func $dug (param $n i32) (result)\n        (local $idx i32)\n        (local $loop_idx i32)\n        (local $sp\' i32)\n        (local $top i64)\n        (local.set $sp\' (i32.add (global.get $sp) (local.get $n)))\n        (local.tee $idx (global.get $sp))\n        (local.tee $loop_idx)\n        (i32.mul (i32.const 8))\n        i64.load\n        local.set $top\n        (loop $loop\n          (i32.mul (i32.const 8) (local.get $idx))\n          (i32.add (local.get $loop_idx) (i32.const 1))\n          local.tee $loop_idx\n          (i32.mul (i32.const 8))\n          i64.load\n          i64.store\n          (local.set $idx (i32.add (local.get $idx) (i32.const 1)))\n          (local.get $idx)\n          (local.get $sp\')\n          i32.lt_u\n          br_if $loop)\n    \n        (i64.store (i32.mul (i32.const 8) (local.get $sp\')) (local.get $top)))\n    \n      (func $dig (param $n i32) (result)\n        (local $idx i32) (local $t i32) (local $digged i64)\n    \n        (local.set $digged\n          (i64.load\n            (i32.mul (i32.const 8)\n              (local.tee $idx (i32.add (global.get $sp) (local.get $n))))))\n    \n        (loop $loop\n          (local.set $t (i32.mul (i32.const 8) (local.get $idx)))\n    \n          (i64.store (local.get $t)\n            (i64.load\n              (i32.mul\n                (i32.const 8)\n                (local.tee $idx (i32.sub (local.get $idx) (i32.const 1))))))\n    \n          (br_if $loop\n            (i32.lt_u (global.get $sp) (local.get $idx))))\n    \n        (i64.store (i32.mul (i32.const 8) (local.get $idx)) (local.get $digged)))\n    \n      (func $pop (result i64)\n        (local $spp i32)\n        (i32.mul (i32.const 8) (local.tee $spp (global.get $sp)))\n        i64.load\n        (global.set $sp (i32.add (local.get $spp) (i32.const 1))))  ;;set stackptr\n    \n      (func $push (param $value i64) (result)\n        (local $spp i32)\n        (i32.mul (i32.const 8) (local.tee $spp (i32.sub (global.get $sp) (i32.const 1)) ))\n        (i64.store (local.get $value))\n        (global.set $sp (local.get $spp)))  ;;set stackptr\n    \n      (func $drop (param $n i32) (result)\n        (global.set $sp (i32.add (global.get $sp) (local.get $n))))  ;;set stackptr\n    \n      (table $closures funcref (elem ))\n    \n    \n      (func $main (param $v1 i64) (result i64)\n        (local $1 i64)\n        (call $push (local.get $v1))\n        (call $unpair (call $pop)) ;; implicit return\n    (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $swap)\n    (call $push (call $z_sub (call $pop) (call $pop)))) (else (call $push (call $z_add (call $pop) (call $pop)))))) (else (call $drop (i32.const 2))\n    (call $push (call $zero)) (; 0 ;)))\n    (call $push (call $nil))\n    (call $push (call $pair (call $pop) (call $pop)))\n        (call $pop))\n    \n      (export "push" (func $push))\n      (export "pop" (func $push))\n      (export "main" (func $main))\n      (export "closures" (table $closures))\n      (export "call_callback" (func $call_callback))\n      (export "call_callback_unit" (func $call_callback_unit))\n      )\n    ',dekuC:new class{constructor(n){console.log("dekuc params",n)}originateContract(n){let{initialStorage:t,code:e}=n;return console.log("deploying with",t,e),new Promise((n=>setTimeout((()=>n("DK1LiabSxPyVUmVZCqHneCFLJrqQcLHkmX9d")),3e3)))}contract(n){return{invoke:function(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];return console.log("invoked params",t)},subscribe:function(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];return console.log("subscribe params",t)}}}}({signer:r,dekuRPC:"https://deku-canonical-vm0.deku-v1.marigold.dev/",tezosRPC:"https://ghostnet.tezos.marigold.dev/"}),typeUtilities:i}},40621:(n,t,e)=>{"use strict";e.r(t),e.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=e(87462),i=(e(27378),e(3905));e(52263),e(94184),e(67294),e(94971),e(4270);const r={sidebar_position:2},o=void 0,l={unversionedId:"Deku-Canonical/dekuc_quickstart",id:"Deku-Canonical/dekuc_quickstart",title:"dekuc_quickstart",description:"Under construction!",source:"@site/../docs/Deku-Canonical/dekuc_quickstart.md",sourceDirName:"Deku-Canonical",slug:"/Deku-Canonical/dekuc_quickstart",permalink:"/docs/Deku-Canonical/dekuc_quickstart",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/../docs/Deku-Canonical/dekuc_quickstart.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Deku Canonical",permalink:"/docs/category/deku-canonical"},next:{title:"Deku-C CLI",permalink:"/docs/Deku-Canonical/deku_c_cli"}},c={},s=[],u={toc:s};function p(n){let{components:t,...e}=n;return(0,i.kt)("wrapper",(0,a.Z)({},u,e,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Under construction!"))}p.isMDXComponent=!0},94971:(n,t,e)=>{"use strict";e.d(t,{Z:()=>a});const a={playgroundEditorWrapper:"playgroundEditorWrapper_NVrK",liveEditorBg:"liveEditorBg_jBTB",playgroundHeader:"playgroundHeader_qwyd",playgroundEditorHeader:"playgroundEditorHeader_nLzM",playgroundPreviewHeader:"playgroundPreviewHeader_vpQ2",playgroundPreview:"playgroundPreview_bb8I",button:"button_G4Yn",copyButton:"copyButton_q7gX",runButton:"runButton_oaHB"}},35883:()=>{},46601:()=>{},89214:()=>{},52361:()=>{},94616:()=>{}}]);